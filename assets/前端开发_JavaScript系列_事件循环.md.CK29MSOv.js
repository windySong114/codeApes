import{_ as t,c as a,o as p,a7 as e}from"./chunks/framework.DZKVYKRh.js";const J=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端开发/JavaScript系列/事件循环.md","filePath":"前端开发/JavaScript系列/事件循环.md"}'),i={name:"前端开发/JavaScript系列/事件循环.md"},r=e('<div style="text-align:center;"><h1>事件循环</h1></div><h3 id="一、模块化" tabindex="-1">一、模块化 <a class="header-anchor" href="#一、模块化" aria-label="Permalink to &quot;一、模块化&quot;">​</a></h3><p>1、含义：将复杂的分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率</p><h3 id="二、程序" tabindex="-1">二、程序 <a class="header-anchor" href="#二、程序" aria-label="Permalink to &quot;二、程序&quot;">​</a></h3><p>1、含义：是一组指令和数据的集合，用于执行特定任务或完成特定工作。它是静态的，是存储在磁盘或其他媒体上的可执行文件。程序本身只是一些代码和数据的集合，并不占用系统的运行资源</p><h3 id="三、进程" tabindex="-1">三、进程 <a class="header-anchor" href="#三、进程" aria-label="Permalink to &quot;三、进程&quot;">​</a></h3><p>1、含义：是程序的一次执行。当程序运行时，操作系统会为其分配资源（如内存、文件描述符等），形成一个独立的进程。每个进程都有自己的地址空间，独立于其他进程。进程是计算机系统中资源分配的基本单位，它可以包含一个或多个线程</p><p>2、分类（浏览器）</p><p>（1）主进程：浏览器的核心进程</p><p>①负责浏览器界面显示，文件的输入输出，与用户交互。如前进，后退等</p><p>②负责各个页面的管理，创建和销毁其他进程、GPU进程等</p><p>③调度其他进程</p><p>④将Renderer（渲染器）进程得到的内存中的Bitmap，绘制到用户界面上</p><p>⑤网络资源的管理，下载等</p><p>（2）渲染进程（浏览器内核）：（Renderer（渲染器），内部是多线程的）默认每个Tab页面一个进程，互不影响；用于页面渲染，脚本执行，事件处理等。渲染进程通常包含多个线程</p><p>①JS引擎线程（主线程）：</p><ul><li><p>“JavaScript 引擎”通常被称作一种 虚拟机。也称为JS内核，负责处理JavaScript脚本程序。（例如V8引擎）</p></li><li><p>JSt引擎线程负责解析JavaScript脚本，运行代码</p></li><li><p>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</p></li><li><p>同样注意，GUI渲染线程与JavaScript引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</p></li></ul><p>②GUI渲染线程</p><ul><li><p>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等</p></li><li><p>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</p></li><li><p>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行，互斥原因：由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致</p></li></ul><p>③事件触发线程</p><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul><p>④定时触发器线程</p><ul><li>setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li></ul><p>⑤异步http请求线程</p><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行</li></ul><p>（3）网络进程：网络进程负责处理网络请求和响应。它与渲染进程分离，以防止网络请求的阻塞影响用户界面的响应性</p><p>（4）GPU 进程：最多一个，负责处理页面的 3D 渲染和加速，以提高页面性能和响应速度。它独立于渲染进程，可以利用计算机的 GPU 资源来执行图形相关的任务</p><p>（5）插件进程：责运行浏览器插件，如 Flash、Silverlight 等，每种类型的插件对应一个进程，仅当使用该插件时才创建</p><p>（6）扩展进程：如果浏览器支持扩展或插件，可能会有一个或多个进程用于管理这些扩展和插件</p><h3 id="四、线程" tabindex="-1">四、线程 <a class="header-anchor" href="#四、线程" aria-label="Permalink to &quot;四、线程&quot;">​</a></h3><p>（1）含义：是进程中的一个执行单元，是操作系统调度的最小单位。一个进程可以包含多个线程，它们共享相同的地址空间和资源。线程之间可以更方便地共享数据，因为它们在同一个进程中。线程比进程更轻量级，创建和切换的开销相对较小</p><h3 id="五、任务队列" tabindex="-1">五、任务队列 <a class="header-anchor" href="#五、任务队列" aria-label="Permalink to &quot;五、任务队列&quot;">​</a></h3><p>1、作用：用于管理异步代码的执行顺序</p><p>2、分类</p><p>（1）主线程任务队列：所有的同步任务和微任务都会进入这个队列</p><p>（2）微任务队列：用于存放微任务</p><p>（3）宏任务队列：用于存放宏任务</p><p>（4）动画帧任务队列：用于存放通过<code>requestAnimationFrame</code>注册的动画回调函数。这个队列的执行时机通常与浏览器的刷新频率一致，为每一帧的动画更新提供了便利</p><h3 id="六、任务-执行优先级-微任务、交互任务和延时任务" tabindex="-1">六、任务（执行优先级：微任务、交互任务和延时任务） <a class="header-anchor" href="#六、任务-执行优先级-微任务、交互任务和延时任务" aria-label="Permalink to &quot;六、任务（执行优先级：微任务、交互任务和延时任务）&quot;">​</a></h3><p>1、同步任务：同步任务是按照它们在代码中出现的顺序依次执行的任务。当执行一个同步任务时，JavaScript引擎会阻塞代码的执行，直到该任务执行完成，然后才会继续执行下一个任务。同步任务通常包括函数调用、变量赋值等，它们的执行顺序是确定的，不会被打断</p><p>2、异步任务</p><p>（1）含义：异步任务是在当前任务执行过程中，不会阻塞代码的执行，而是在将来的某个时刻执行的任务。异步任务通常包括网络请求、定时器、事件监听器等。JavaScript通过事件循环（Event Loop）来处理异步任务的执行</p><p>（2）类型</p><p>①微任务：由JS引擎发起，在当前任务执行完成后、下一个事件循环开始之前执行</p><table tabindex="0"><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>promise(promise本身是同步的，then/catch/finally是异步的)</td><td>是</td><td>是</td></tr><tr><td>async/await</td><td>是</td><td>是</td></tr><tr><td>process.nextTick</td><td>否</td><td>是</td></tr><tr><td>MutationObserver（监视DOM树变化）</td><td>是</td><td>否</td></tr></tbody></table><p>②宏任务：由宿主环境发起（浏览器、node），在当前事件循环的末尾执行</p><table tabindex="0"><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>setTimeout</td><td>是</td><td>是</td></tr><tr><td>setInterval</td><td>是</td><td>是</td></tr><tr><td>事件监听器中的回调（如点击事件，addEventListener、on、input、change方法等）</td><td>是</td><td>是</td></tr><tr><td>I/O 操作</td><td>是</td><td>是</td></tr><tr><td>setImmediate</td><td>否</td><td>是</td></tr><tr><td>requestAnimationFrame</td><td>是</td><td>否</td></tr></tbody></table><p>3、交互任务（一般为宏任务）：</p><p>（1）含义：交互任务通常是由用户触发的交互事件，例如点击、滚动、键盘输入等。这些任务会被放入事件队列中，在特定的事件触发时执行。由于交互任务是由用户触发的，因此它们的执行时间是不确定的，但通常会在很短的时间内得到响应</p><p>（2）交互事件</p><ul><li><p>用户点击页面上的按钮或链接触发的事件</p></li><li><p>键盘输入事件</p></li><li><p>鼠标移动、点击或滚动等事件</p></li><li><p>XMLHttpRequest、Fetch API 发送网络请求等异步操作的回调</p></li></ul><p>4、延时任务（一般为宏任务）：延时任务是通过定时器函数（例如 <code>setTimeout</code>、<code>setInterval</code>）指定的任务，在一定时间后执行。这些任务会被放入定时器队列中，在指定的延迟时间后执行。与交互任务不同，延时任务的执行时间是确定的，因为它们是由定时器函数明确指定的</p><h3 id="七、程序、进程和线程的关系" tabindex="-1">七、程序、进程和线程的关系 <a class="header-anchor" href="#七、程序、进程和线程的关系" aria-label="Permalink to &quot;七、程序、进程和线程的关系&quot;">​</a></h3><p>（1）一个程序可以包含一个或多个进程</p><p>（2）一个进程可以包含一个或多个线程</p><p>（3）进程之间是相互独立的，每个进程有自己的独立内存空间</p><p>（4）线程之间共享同一个进程的资源，如公共资源，全局代码，内存空间，文件句柄等，但不能共享线程的独有资源，如线程的栈指针（标识数据）</p><h3 id="八、javascript是单线程的脚本语言" tabindex="-1">八、JavaScript是单线程的脚本语言 <a class="header-anchor" href="#八、javascript是单线程的脚本语言" aria-label="Permalink to &quot;八、JavaScript是单线程的脚本语言&quot;">​</a></h3><p>（1）含义：一个时间内只能处理一个事情，严格按照单线程（从上到下、从左到右的方式）执行代码逻辑，进行代码的解释和运行</p><p>（2）局限性：在同一个时间只能做一件事，这就导致了页面渲染和事件的执行，在这个过程中无法进行</p><p>（3）局限性解决方案：采用同步模块模式和异步模块模式执行</p><ul><li><p>同步模块模式：阻塞模式，请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用</p></li><li><p>异步模块模式：非阻塞模式，请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用</p></li></ul><p>（4）JS执行机制：js是单线程的，每当执行函数就把函数推入栈中，但有异步的操作就让浏览器的线程（webAPI）去处理，处理完放到任务队列里，当主线程（执行栈）执行完毕时，如果任务队列里有任务，就执行</p><h3 id="九、事件循环" tabindex="-1">九、事件循环 <a class="header-anchor" href="#九、事件循环" aria-label="Permalink to &quot;九、事件循环&quot;">​</a></h3><p>1、描述：在事件循环中，当一个宏任务执行完成后，会检查微任务队列是否有微任务需要执行，如果有，则优先执行微任务，直到微任务队列为空。然后，事件循环会检查宏任务队列是否有待执行的宏任务，如果有，则取出一个宏任务执行。这样，微任务和宏任务不断地交替执行，构成了 JavaScript 的异步执行模型</p><p>2、执行顺序</p><p>（1）执行同步任务直到执行栈为空</p><p>（2）检查微任务队列，如果有微任务，依次执行微任务直到微任务队列为空</p><p>（3）从宏任务队列中取出一个宏任务执行，执行完毕后回到第二步</p><p>（4）重复以上步骤</p>',70),d=[r];function l(o,h,n,c,s,u){return p(),a("div",null,d)}const m=t(i,[["render",l]]);export{J as __pageData,m as default};
