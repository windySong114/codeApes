import{_ as t,c as l,o as i,a7 as e}from"./chunks/framework.DZKVYKRh.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端开发/JavaScript系列/http和https.md","filePath":"前端开发/JavaScript系列/http和https.md"}'),a={name:"前端开发/JavaScript系列/http和https.md"},h=e('<div style="text-align:center;"><h1>http和https</h1></div><ol><li><h2 id="http-和-https-的区别" tabindex="-1">http 和 https 的区别 <a class="header-anchor" href="#http-和-https-的区别" aria-label="Permalink to &quot;http 和 https 的区别&quot;">​</a></h2><ul><li>http 的 url 由 <a href="http://xn--phq77am0hzsh1m2btihlp4axbdd57c" target="_blank" rel="noreferrer">http://起始且默认使用端口</a> 80，而 https 的 url 由 <a href="https://xn--phq77am0hzsh1m2btihlp4axbdd57c" target="_blank" rel="noreferrer">https://起始且默认使用端口</a> 443</li><li>http 是超文本传输协议信息是明文传输，而 https 则是具有安全性的 SSL 加密传输协议</li><li>http 的连接很简单是无状态的，而 https 是由 http+ssl 构建的可进行加密传输，身份认证的网络协议比http 协议安全</li></ul></li><li><h2 id="https-协议工作原理" tabindex="-1">https 协议工作原理 <a class="header-anchor" href="#https-协议工作原理" aria-label="Permalink to &quot;https 协议工作原理&quot;">​</a></h2><ul><li>客户端使用 url 访问服务器，要求服务器建立 ssl 链接</li><li>web 服务器收到请求后将网站的证书（包含公钥）返回给客户端</li><li>客户端和服务器协商 ssl 链接的安全等级，就是加密等级</li><li>客户端，浏览器协商一致的安全等级建立会话密钥，通过网站的公钥来加密会话密钥，并传送给网站</li><li>服务器通过自己的私钥解密出会话密钥</li><li>web 服务器通过会话密钥加密与客户端之间的通信</li></ul></li><li><h2 id="http1-1-和-http2-0-的区别" tabindex="-1">http1.1 和 http2.0 的区别 <a class="header-anchor" href="#http1-1-和-http2-0-的区别" aria-label="Permalink to &quot;http1.1 和 http2.0 的区别&quot;">​</a></h2><ul><li>http2 采用二进制文本传输格式而非 http1 的文本格式，二进制在协议的解析和扩展更好</li><li>数据压缩：对信息头采用了 HPACK 进行压缩传输，节省了信息头带来的网络流量</li><li>多路复用：一个链接可以并发处理多个请求</li><li>服务器推送：我们对支持 http2 的一些 web sever，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建链接请求到服务端获取</li></ul></li><li><h2 id="get-和-post-的区别" tabindex="-1">get 和 post 的区别 <a class="header-anchor" href="#get-和-post-的区别" aria-label="Permalink to &quot;get 和 post 的区别&quot;">​</a></h2><ul><li>get 在浏览器回退时是无害的，而 post 会再次提交请求</li><li>get 产生的 url 地址可以被收藏，而 post 不可以</li><li>get 请求会被浏览器主动缓存，而 post 不可以</li><li>get 请求只能进行 url 编码，而 post 支持多种编码方式</li><li>get 请求参数会被完整保留在浏览器历史记录里，而 post 中的请求参数不会被保留</li><li>get 请求在 url 传送中有长度限制，而 post 没有限制</li><li>get 只接受 ascll 字符，而 post 没有限</li><li>get 通过 url 传递，post 放在 request body 中</li><li>get 没有 post 安全，因为参数直接暴露在 url 上，所以不能用来传递敏感信息</li></ul></li><li><h2 id="http的请求报文结构" tabindex="-1">http的请求报文结构 <a class="header-anchor" href="#http的请求报文结构" aria-label="Permalink to &quot;http的请求报文结构&quot;">​</a></h2><ul><li>报文结构：请求行、请求头、空行、请求体</li></ul></li><li><h2 id="网页从输入网址到浏览器渲染完成的过程" tabindex="-1">网页从输入网址到浏览器渲染完成的过程 <a class="header-anchor" href="#网页从输入网址到浏览器渲染完成的过程" aria-label="Permalink to &quot;网页从输入网址到浏览器渲染完成的过程&quot;">​</a></h2><ul><li>浏览器的地址栏输入 url 按下回车，浏览器查找当前 url 是否存在缓存，并比较缓存是否过期</li><li>发送到dns服务器，dns 解析 url 对应的 ip</li><li>根据 ip 建立 tcp 连接（三次握手） <ul><li>主机向服务器发送一个建立连接的请求</li><li>服务器接收到请求后发送同意连接的信号</li><li>主机接到同意连接的信号后，再次向服务器发送确认信号，自此主机与服务器两者建立了连接</li></ul></li><li>http发送请求（请求报文，HTTP协议的通信内容）</li><li>服务器处理请求，浏览器接收 http 响应</li><li>浏览器渲染页面，构建 dom 树，生成相应的页面 <ul><li>解析 HTML 文档</li><li>解析过程中遇到图片、样式表、js文件，启动下载</li><li>HTML 解析并构建 DOM Tree</li><li>CSS 解析 Style Rules，并构建 CSSOM 树</li><li>两者关联生成 Render Tree</li><li>Layout（布局）根据 Render Tree 计算每个节点的信息，此处为回流过程</li><li>Painting 根据渲染树和布局信息开始绘制页面上的每个元素</li></ul></li></ul></li><li><h2 id="内存泄漏" tabindex="-1">内存泄漏 <a class="header-anchor" href="#内存泄漏" aria-label="Permalink to &quot;内存泄漏&quot;">​</a></h2><ul><li>原因： <ul><li>全局变量</li><li>dom 清空时还在调用</li><li>在 ie 中使用闭包</li><li>定时器未清理</li><li>子元素存在引起内存泄漏</li></ul></li><li>解决： <ul><li>减少不必要的全局变量或者生命周期较长的对象</li><li>及时对无用的数据进行垃圾回收</li><li>避免创建过多的对象，不用了的东西要归还</li><li>减少层级过多的引用</li></ul></li></ul></li></ol>',2),r=[h];function p(s,o,u,n,d,c){return i(),l("div",null,r)}const m=t(a,[["render",p]]);export{b as __pageData,m as default};
