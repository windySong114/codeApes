import{_ as t,c as e,o as i,a7 as d}from"./chunks/framework.DZKVYKRh.js";const a="/codeApes/assets/lifecycle.B5vwBpD7.png",y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端开发/Vue系列/对Vue的理解.md","filePath":"前端开发/Vue系列/对Vue的理解.md"}'),s={name:"前端开发/Vue系列/对Vue的理解.md"},l=d('<div style="text-align:center;"><h1>对Vue的理解</h1></div><ol><li><h2 id="渐进式javascript框架" tabindex="-1">渐进式JavaScript框架 <a class="header-anchor" href="#渐进式javascript框架" aria-label="Permalink to &quot;渐进式JavaScript框架&quot;">​</a></h2><table><tr><td style="width:70px;">含义</td><td>Vue的核心功能是视图模板引擎（支持数据驱动和组件化开发模式）；Vue作为一个核心库，在视图模板引擎（声明式渲染）的基础上，可以相互独立地添加组件系统、客户端路由、状态管理等构建一个完整的框架</td></tr></table></li><li><h2 id="单页应用-spa-的web应用框架" tabindex="-1">单页应用（SPA）的Web应用框架 <a class="header-anchor" href="#单页应用-spa-的web应用框架" aria-label="Permalink to &quot;单页应用（SPA）的Web应用框架&quot;">​</a></h2><table><tr><td style="width:70px;">含义</td><td>由一个主页面和多个页面片段构成，通过路由切换页面内容，只在初始化时加载主要资源</td></tr><tr><td style="width:70px;">优点</td><td>页面切换时，异步加载数据和更新DOM，响应速度快；局部刷新，内容变化时，整个页面不需要重新加载；良好的前后端分离，分工更明确</td></tr><tr><td style="width:70px;">缺点</td><td>不利于搜索引擎的抓取；首屏渲染速度相对较慢</td></tr></table></li><li><h2 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h2><ul><li><h3 id="数据驱动-mvvm" tabindex="-1">数据驱动（MVVM） <a class="header-anchor" href="#数据驱动-mvvm" aria-label="Permalink to &quot;数据驱动（MVVM）&quot;">​</a></h3></li></ul><table><tr><td style="width:150px;">Model（模型层）</td><td>处理业务逻辑以及和服务端的交互</td></tr><tr><td style="width:150px;">View（视图层）</td><td>将数据模型转化为UI展示</td></tr><tr><td style="width:150px;">View Model（视图模型层）</td><td>连接模型层和视图层，监听模型层数据变化，控制视图层的更新</td></tr></table><ul><li><h3 id="组件化" tabindex="-1">组件化 <a class="header-anchor" href="#组件化" aria-label="Permalink to &quot;组件化&quot;">​</a></h3></li></ul><table><tr><td style="width:70px;">含义</td><td>从UI界面角度划分，把一些UI元素抽离成单个组件，一个.vue文件可以视为一个组件，如弹窗组件、日历组件等</td></tr><tr><td style="width:70px;">优点</td><td>便于UI组件的复用、测试、和维护，降低系统的耦合度</td></tr></table><ul><li><h3 id="指令系统" tabindex="-1">指令系统 <a class="header-anchor" href="#指令系统" aria-label="Permalink to &quot;指令系统&quot;">​</a></h3></li></ul><table><tr><td style="width:100px;">v-if</td><td>条件渲染</td></tr><tr><td style="width:100px;">v-for</td><td>列表渲染</td></tr><tr><td style="width:100px;">v-bind</td><td>属性绑定</td></tr><tr><td style="width:100px;">v-on</td><td>事件绑定，只监听自定义事件</td></tr><tr><td style="width:100px;">v-model</td><td>双向数据绑定指令</td></tr><tr><td style="width:100px;">v-show</td><td>通过 CSS 的 display 切换元素的显示与隐藏</td></tr><tr><td style="width:100px;">v-pre</td><td>跳过元素及其子元素的编译过程</td></tr><tr><td style="width:100px;">v-slot</td><td>插槽</td></tr><tr><td style="width:100px;">v-html</td><td>将数据作为 HTML 插入到元素中,更新元素的 innerHTML</td></tr><tr><td style="width:100px;">v-text</td><td>展示文本，更新元素的 textContent</td></tr><tr><td style="width:100px;">v-once</td><td>只渲染元素和组件一次</td></tr><tr><td style="width:100px;">v-cloak</td><td>保持在元素上直到关联实例结束编译</td></tr></table></li><li><h2 id="响应式" tabindex="-1">响应式 <a class="header-anchor" href="#响应式" aria-label="Permalink to &quot;响应式&quot;">​</a></h2></li></ol><ul><li>Vue 的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过 Object.defineProperty() 来劫持对象数据的 setter 和 getter 操作</li><li>通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化-&gt;视图更新 在初始化 vue 实例时，遍历 data 这个对象，给每一个键值对利用 Object.definedProperty 对 data 的键值对新增 get 和 set 方法，利用了 事件监听 DOM 的机制，让视图去改变数据</li><li>利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的</li></ul><ol start="5"><li><h2 id="vue实例化及生命周期" tabindex="-1">Vue实例化及生命周期 <a class="header-anchor" href="#vue实例化及生命周期" aria-label="Permalink to &quot;Vue实例化及生命周期&quot;">​</a></h2><ul><li><p>生命周期流程示意图 <img src="'+a+`" alt=""></p></li><li><p>生命周期</p><ul><li>含义：在Vue中实例从创建到销毁的过程就是生命周期，Vue生命周期钩子会自动绑定 this 上下文到实例中，钩子即生命周期的回调函数</li><li>具体流程如下：<table><tr><td style="width:80px;" rowspan="6">阶段一</td><td style="width:110px;text-align:center;" rowspan="6"> 创建<br>（初始化，完成data数据创建） </td><td style="width:200px;">new Vue(options)</td><td>创建实例</td></tr><tr><td style="width:200px;">init Events &amp; Lifecycle</td><td>初始化完成事件和生命周期，等待生命周期依次调用 <br>（1）事件相关的实例属性和方法：$data、$props、$el等 <br>（2）生命周期：beforeCreate、created等 </td></tr><tr><td style="width:200px;">beforeCreate</td><td>调用beforeCreate生命周期钩子函数，无法通过vm访问data中的数据和methods中的方法，this为undefined</td></tr><tr><td style="width:200px;">init injections &amp; reactivity</td><td>初始化依赖注入和响应式系统： <br>（1）通过 provide 和 inject 选项进行注入 <br>（2）初始化props、data、methods、computed和watch中的响应式数据和方法</td></tr><tr><td style="width:200px;">created</td><td>调用created，Vue 实例初始化完成，可以通过vm访问data中的数据和methods中的方法；节点尚未挂载，无法获取DOM节点</td></tr><tr><td style="width:200px;"> Has el option <br>Has template option</td><td>是否有el选项；是，调用$mount()方法进行页面的挂载，否，检查是否有template选项，是，将template编译为render函数，否，编译el的outHTML作为模板</td></tr><tr><td style="width:80px;" rowspan="3">阶段二</td><td style="width:110px;text-align:center;" rowspan="3"> 挂载<br>（完成初始渲染，data数据渲染到el） </td><td style="width:200px;">beforeMount</td><td>模板编译完成，调用 render 函数生成虚拟DOM</td></tr><tr><td style="width:200px;">Create vm $el and replace &quot;el&quot; with it</td><td>把在内存中渲染好的模板结构替换掉el属性指定的DOM元素,即通过_update方法将虚拟DOM生成真实DOM结构，并且渲染到页面中</td></tr><tr><td style="width:200px;">mounted</td><td>vue 实例挂载到真实 DOM 上，可以通过 DOM 获取 DOM 节点；注：所有子组件无法保证都被挂载完成，可以使用vm.$nextTick()方法等到视图渲染完毕，再执行操作</td></tr><tr><td style="width:80px;" rowspan="3">阶段三</td><td style="width:110px;text-align:center;" rowspan="3"> 更新<br></td><td style="width:200px;">beforeUpdate</td><td>data中的数据是最新的，页面上渲染的数据是旧数据，即：页面和数据不同步</td></tr><tr><td style="width:200px;">virtual DOM re-render and patch</td><td>根据新数据，生成新的虚拟DOM，随后与旧的虚拟DOM进行比较，最终完成页面更新，即：完成了Model-&gt;View的更新</td></tr><tr><td style="width:200px;">updated</td><td>页面和数据都是最新的，即：页面数据保存一致，注：updated 无法保证所有的子组件都被重新渲染完毕，可以使用vm.$nextTick()方法等到视图渲染完毕，再执行操作</td></tr><tr><td style="width:80px;" rowspan="3">阶段四</td><td style="width:110px;text-align:center;" rowspan="3"> 销毁<br></td><td style="width:200px;">beforeDestroy</td><td>即将执行组件销毁过程，data、methods和指令等还处于可用状态；在此阶段，可以进行清除定时器、取消订阅消息和解绑事件监听等操作</td></tr><tr><td style="width:200px;">Teardown watchers,child components and event listeners</td><td>销毁组件的数据监视器、子组件和事件侦听器</td></tr><tr><td style="width:200px;">destory</td><td>数据监视器、子组件和事件侦听器卸载完成，注：DOM元素存在，不受vue控制，但原生DOM事件有效</td></tr></table></li><li>其他生命周期 <ul><li><p>activited：被 keep-alive 缓存的组件激活时调用</p></li><li><p>deactivated：被 keep-alive 缓存的组件停用时调用</p></li><li><p>errorCaptured（2.5.0+新增）：在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播</p><div class="language-vue vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  errorCaptured</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在这里处理错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;父组件捕获到子组件错误：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, err, vm, info);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li></ul></li><li>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分 <ul><li>加载渲染过程：父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li><li>子组件更新过程： 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li><li>父组件更新过程： 父 beforeUpdate -&gt; 父 updated</li><li>销毁过程： 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul></li><li>注：从创建到挂载，是从外到内，再从内到外，且mixins的钩子函数总是在当前组件之前执行</li></ul></li></ul></li></ol>`,4),r=[l];function n(p,h,o,c,u,k){return i(),e("div",null,r)}const x=t(s,[["render",n]]);export{y as __pageData,x as default};
